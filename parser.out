Grammar:

Rule 0     S' -> program
Rule 1     program -> instructions_opt
Rule 2     instructions_opt -> <empty>
Rule 3     instructions_opt -> instructions
Rule 4     instructions -> instruction
Rule 5     instructions -> instructions instruction
Rule 6     expr -> number
Rule 7     expr -> matrix_function
Rule 8     expr -> transposition
Rule 9     expr -> matrix
Rule 10    expr -> uminus
Rule 11    expr -> ID
Rule 12    expr -> expr DOTDIV expr  [precedence=left, level=6]
Rule 13    expr -> expr DOTMUL expr  [precedence=left, level=6]
Rule 14    expr -> expr DOTSUB expr  [precedence=left, level=4]
Rule 15    expr -> expr DOTADD expr  [precedence=left, level=4]
Rule 16    expr -> expr / expr  [precedence=left, level=5]
Rule 17    expr -> expr * expr  [precedence=left, level=5]
Rule 18    expr -> expr - expr  [precedence=left, level=3]
Rule 19    expr -> expr + expr  [precedence=left, level=3]
Rule 20    condition -> expr NE expr
Rule 21    condition -> expr EQ expr
Rule 22    condition -> expr GE expr
Rule 23    condition -> expr GT expr
Rule 24    condition -> expr LE expr
Rule 25    condition -> expr LT expr
Rule 26    uminus -> - expr  [precedence=right, level=7]
Rule 27    transposition -> expr '  [precedence=left, level=8]
Rule 28    matrix -> [ vectors ]
Rule 29    vectors -> vector
Rule 30    vectors -> vectors , vector
Rule 31    vector -> [ elements ]
Rule 32    elements -> element
Rule 33    elements -> elements , element
Rule 34    element -> number
Rule 35    element -> ID
Rule 36    number -> FLOATNUM
Rule 37    number -> INTNUM
Rule 38    matrix_init -> ID [ INTNUM , INTNUM ]
Rule 39    vector_init -> ID [ INTNUM ]
Rule 40    matrix_function -> ZEROS ( INTNUM )
Rule 41    matrix_function -> ONES ( INTNUM )
Rule 42    matrix_function -> EYE ( INTNUM )
Rule 43    assignment -> vector_init assign_op expr
Rule 44    assignment -> matrix_init assign_op expr
Rule 45    assignment -> ID assign_op expr
Rule 46    instruction -> instruction_end ;
Rule 47    instruction -> { instructions }
Rule 48    instruction -> FOR ID = expr : expr instruction
Rule 49    instruction -> WHILE ( condition ) instruction
Rule 50    instruction -> IF ( condition ) instruction ELSE instruction  [precedence=nonassoc, level=2]
Rule 51    instruction -> IF ( condition ) instruction  [precedence=nonassoc, level=1]
Rule 52    instruction_end -> PRINT to_print
Rule 53    instruction_end -> CONTINUE
Rule 54    instruction_end -> BREAK
Rule 55    instruction_end -> RETURN expr
Rule 56    instruction_end -> assignment
Rule 57    assign_op -> DIVASSIGN
Rule 58    assign_op -> MULASSIGN
Rule 59    assign_op -> SUBASSIGN
Rule 60    assign_op -> ADDASSIGN
Rule 61    assign_op -> =
Rule 62    to_print -> STRING , to_print
Rule 63    to_print -> expr , to_print
Rule 64    to_print -> expr
Rule 65    to_print -> STRING

Terminals, with rules where they appear:

'                    : 27
(                    : 40 41 42 49 50 51
)                    : 40 41 42 49 50 51
*                    : 17
+                    : 19
,                    : 30 33 38 62 63
-                    : 18 26
/                    : 16
:                    : 48
;                    : 46
=                    : 48 61
ADDASSIGN            : 60
BREAK                : 54
CONTINUE             : 53
DIVASSIGN            : 57
DOTADD               : 15
DOTDIV               : 12
DOTMUL               : 13
DOTSUB               : 14
ELSE                 : 50
EQ                   : 21
EYE                  : 42
FLOATNUM             : 36
FOR                  : 48
GE                   : 22
GT                   : 23
ID                   : 11 35 38 39 45 48
IF                   : 50 51
INTNUM               : 37 38 38 39 40 41 42
LE                   : 24
LT                   : 25
MULASSIGN            : 58
NE                   : 20
ONES                 : 41
PRINT                : 52
RETURN               : 55
STRING               : 62 65
SUBASSIGN            : 59
WHILE                : 49
ZEROS                : 40
[                    : 28 31 38 39
]                    : 28 31 38 39
error                : 
{                    : 47
}                    : 47

Nonterminals, with rules where they appear:

assign_op            : 43 44 45
assignment           : 56
condition            : 49 50 51
element              : 32 33
elements             : 31 33
expr                 : 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 27 43 44 45 48 48 55 63 64
instruction          : 4 5 48 49 50 50 51
instruction_end      : 46
instructions         : 3 5 47
instructions_opt     : 1
matrix               : 9
matrix_function      : 7
matrix_init          : 44
number               : 6 34
program              : 0
to_print             : 52 62 63
transposition        : 8
uminus               : 10
vector               : 29 30
vector_init          : 43
vectors              : 28 30


state 0

    (0) S' -> . program
    (1) program -> . instructions_opt
    (2) instructions_opt -> .
    (3) instructions_opt -> . instructions
    (4) instructions -> . instruction
    (5) instructions -> . instructions instruction
    (46) instruction -> . instruction_end ;
    (47) instruction -> . { instructions }
    (48) instruction -> . FOR ID = expr : expr instruction
    (49) instruction -> . WHILE ( condition ) instruction
    (50) instruction -> . IF ( condition ) instruction ELSE instruction
    (51) instruction -> . IF ( condition ) instruction
    (52) instruction_end -> . PRINT to_print
    (53) instruction_end -> . CONTINUE
    (54) instruction_end -> . BREAK
    (55) instruction_end -> . RETURN expr
    (56) instruction_end -> . assignment
    (43) assignment -> . vector_init assign_op expr
    (44) assignment -> . matrix_init assign_op expr
    (45) assignment -> . ID assign_op expr
    (39) vector_init -> . ID [ INTNUM ]
    (38) matrix_init -> . ID [ INTNUM , INTNUM ]
    $end            reduce using rule 2 (instructions_opt -> .)
    {               shift and go to state 6
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    PRINT           shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    RETURN          shift and go to state 14
    ID              shift and go to state 8

    program                        shift and go to state 1
    instructions_opt               shift and go to state 2
    instructions                   shift and go to state 3
    instruction                    shift and go to state 4
    instruction_end                shift and go to state 5
    assignment                     shift and go to state 15
    vector_init                    shift and go to state 16
    matrix_init                    shift and go to state 17

state 1

    (0) S' -> program .


state 2

    (1) program -> instructions_opt .
    $end            reduce using rule 1 (program -> instructions_opt .)


state 3

    (3) instructions_opt -> instructions .
    (5) instructions -> instructions . instruction
    (46) instruction -> . instruction_end ;
    (47) instruction -> . { instructions }
    (48) instruction -> . FOR ID = expr : expr instruction
    (49) instruction -> . WHILE ( condition ) instruction
    (50) instruction -> . IF ( condition ) instruction ELSE instruction
    (51) instruction -> . IF ( condition ) instruction
    (52) instruction_end -> . PRINT to_print
    (53) instruction_end -> . CONTINUE
    (54) instruction_end -> . BREAK
    (55) instruction_end -> . RETURN expr
    (56) instruction_end -> . assignment
    (43) assignment -> . vector_init assign_op expr
    (44) assignment -> . matrix_init assign_op expr
    (45) assignment -> . ID assign_op expr
    (39) vector_init -> . ID [ INTNUM ]
    (38) matrix_init -> . ID [ INTNUM , INTNUM ]
    $end            reduce using rule 3 (instructions_opt -> instructions .)
    {               shift and go to state 6
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    PRINT           shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    RETURN          shift and go to state 14
    ID              shift and go to state 8

    instruction                    shift and go to state 18
    instruction_end                shift and go to state 5
    assignment                     shift and go to state 15
    vector_init                    shift and go to state 16
    matrix_init                    shift and go to state 17

state 4

    (4) instructions -> instruction .
    {               reduce using rule 4 (instructions -> instruction .)
    FOR             reduce using rule 4 (instructions -> instruction .)
    WHILE           reduce using rule 4 (instructions -> instruction .)
    IF              reduce using rule 4 (instructions -> instruction .)
    PRINT           reduce using rule 4 (instructions -> instruction .)
    CONTINUE        reduce using rule 4 (instructions -> instruction .)
    BREAK           reduce using rule 4 (instructions -> instruction .)
    RETURN          reduce using rule 4 (instructions -> instruction .)
    ID              reduce using rule 4 (instructions -> instruction .)
    $end            reduce using rule 4 (instructions -> instruction .)
    }               reduce using rule 4 (instructions -> instruction .)


state 5

    (46) instruction -> instruction_end . ;
    ;               shift and go to state 19


state 6

    (47) instruction -> { . instructions }
    (4) instructions -> . instruction
    (5) instructions -> . instructions instruction
    (46) instruction -> . instruction_end ;
    (47) instruction -> . { instructions }
    (48) instruction -> . FOR ID = expr : expr instruction
    (49) instruction -> . WHILE ( condition ) instruction
    (50) instruction -> . IF ( condition ) instruction ELSE instruction
    (51) instruction -> . IF ( condition ) instruction
    (52) instruction_end -> . PRINT to_print
    (53) instruction_end -> . CONTINUE
    (54) instruction_end -> . BREAK
    (55) instruction_end -> . RETURN expr
    (56) instruction_end -> . assignment
    (43) assignment -> . vector_init assign_op expr
    (44) assignment -> . matrix_init assign_op expr
    (45) assignment -> . ID assign_op expr
    (39) vector_init -> . ID [ INTNUM ]
    (38) matrix_init -> . ID [ INTNUM , INTNUM ]
    {               shift and go to state 6
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    PRINT           shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    RETURN          shift and go to state 14
    ID              shift and go to state 8

    instructions                   shift and go to state 20
    instruction                    shift and go to state 4
    instruction_end                shift and go to state 5
    assignment                     shift and go to state 15
    vector_init                    shift and go to state 16
    matrix_init                    shift and go to state 17

state 7

    (48) instruction -> FOR . ID = expr : expr instruction
    ID              shift and go to state 21


state 8

    (45) assignment -> ID . assign_op expr
    (39) vector_init -> ID . [ INTNUM ]
    (38) matrix_init -> ID . [ INTNUM , INTNUM ]
    (57) assign_op -> . DIVASSIGN
    (58) assign_op -> . MULASSIGN
    (59) assign_op -> . SUBASSIGN
    (60) assign_op -> . ADDASSIGN
    (61) assign_op -> . =
    [               shift and go to state 23
    DIVASSIGN       shift and go to state 24
    MULASSIGN       shift and go to state 25
    SUBASSIGN       shift and go to state 26
    ADDASSIGN       shift and go to state 27
    =               shift and go to state 28

    assign_op                      shift and go to state 22

state 9

    (49) instruction -> WHILE . ( condition ) instruction
    (               shift and go to state 29


state 10

    (50) instruction -> IF . ( condition ) instruction ELSE instruction
    (51) instruction -> IF . ( condition ) instruction
    (               shift and go to state 30


state 11

    (52) instruction_end -> PRINT . to_print
    (62) to_print -> . STRING , to_print
    (63) to_print -> . expr , to_print
    (64) to_print -> . expr
    (65) to_print -> . STRING
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    STRING          shift and go to state 32
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    to_print                       shift and go to state 31
    expr                           shift and go to state 33
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 12

    (53) instruction_end -> CONTINUE .
    ;               reduce using rule 53 (instruction_end -> CONTINUE .)


state 13

    (54) instruction_end -> BREAK .
    ;               reduce using rule 54 (instruction_end -> BREAK .)


state 14

    (55) instruction_end -> RETURN . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 47
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 15

    (56) instruction_end -> assignment .
    ;               reduce using rule 56 (instruction_end -> assignment .)


state 16

    (43) assignment -> vector_init . assign_op expr
    (57) assign_op -> . DIVASSIGN
    (58) assign_op -> . MULASSIGN
    (59) assign_op -> . SUBASSIGN
    (60) assign_op -> . ADDASSIGN
    (61) assign_op -> . =
    DIVASSIGN       shift and go to state 24
    MULASSIGN       shift and go to state 25
    SUBASSIGN       shift and go to state 26
    ADDASSIGN       shift and go to state 27
    =               shift and go to state 28

    assign_op                      shift and go to state 48

state 17

    (44) assignment -> matrix_init . assign_op expr
    (57) assign_op -> . DIVASSIGN
    (58) assign_op -> . MULASSIGN
    (59) assign_op -> . SUBASSIGN
    (60) assign_op -> . ADDASSIGN
    (61) assign_op -> . =
    DIVASSIGN       shift and go to state 24
    MULASSIGN       shift and go to state 25
    SUBASSIGN       shift and go to state 26
    ADDASSIGN       shift and go to state 27
    =               shift and go to state 28

    assign_op                      shift and go to state 49

state 18

    (5) instructions -> instructions instruction .
    {               reduce using rule 5 (instructions -> instructions instruction .)
    FOR             reduce using rule 5 (instructions -> instructions instruction .)
    WHILE           reduce using rule 5 (instructions -> instructions instruction .)
    IF              reduce using rule 5 (instructions -> instructions instruction .)
    PRINT           reduce using rule 5 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 5 (instructions -> instructions instruction .)
    BREAK           reduce using rule 5 (instructions -> instructions instruction .)
    RETURN          reduce using rule 5 (instructions -> instructions instruction .)
    ID              reduce using rule 5 (instructions -> instructions instruction .)
    $end            reduce using rule 5 (instructions -> instructions instruction .)
    }               reduce using rule 5 (instructions -> instructions instruction .)


state 19

    (46) instruction -> instruction_end ; .
    {               reduce using rule 46 (instruction -> instruction_end ; .)
    FOR             reduce using rule 46 (instruction -> instruction_end ; .)
    WHILE           reduce using rule 46 (instruction -> instruction_end ; .)
    IF              reduce using rule 46 (instruction -> instruction_end ; .)
    PRINT           reduce using rule 46 (instruction -> instruction_end ; .)
    CONTINUE        reduce using rule 46 (instruction -> instruction_end ; .)
    BREAK           reduce using rule 46 (instruction -> instruction_end ; .)
    RETURN          reduce using rule 46 (instruction -> instruction_end ; .)
    ID              reduce using rule 46 (instruction -> instruction_end ; .)
    $end            reduce using rule 46 (instruction -> instruction_end ; .)
    }               reduce using rule 46 (instruction -> instruction_end ; .)
    ELSE            reduce using rule 46 (instruction -> instruction_end ; .)


state 20

    (47) instruction -> { instructions . }
    (5) instructions -> instructions . instruction
    (46) instruction -> . instruction_end ;
    (47) instruction -> . { instructions }
    (48) instruction -> . FOR ID = expr : expr instruction
    (49) instruction -> . WHILE ( condition ) instruction
    (50) instruction -> . IF ( condition ) instruction ELSE instruction
    (51) instruction -> . IF ( condition ) instruction
    (52) instruction_end -> . PRINT to_print
    (53) instruction_end -> . CONTINUE
    (54) instruction_end -> . BREAK
    (55) instruction_end -> . RETURN expr
    (56) instruction_end -> . assignment
    (43) assignment -> . vector_init assign_op expr
    (44) assignment -> . matrix_init assign_op expr
    (45) assignment -> . ID assign_op expr
    (39) vector_init -> . ID [ INTNUM ]
    (38) matrix_init -> . ID [ INTNUM , INTNUM ]
    }               shift and go to state 50
    {               shift and go to state 6
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    PRINT           shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    RETURN          shift and go to state 14
    ID              shift and go to state 8

    instruction                    shift and go to state 18
    instruction_end                shift and go to state 5
    assignment                     shift and go to state 15
    vector_init                    shift and go to state 16
    matrix_init                    shift and go to state 17

state 21

    (48) instruction -> FOR ID . = expr : expr instruction
    =               shift and go to state 51


state 22

    (45) assignment -> ID assign_op . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 52
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 23

    (39) vector_init -> ID [ . INTNUM ]
    (38) matrix_init -> ID [ . INTNUM , INTNUM ]
    INTNUM          shift and go to state 53


state 24

    (57) assign_op -> DIVASSIGN .
    ID              reduce using rule 57 (assign_op -> DIVASSIGN .)
    FLOATNUM        reduce using rule 57 (assign_op -> DIVASSIGN .)
    INTNUM          reduce using rule 57 (assign_op -> DIVASSIGN .)
    ZEROS           reduce using rule 57 (assign_op -> DIVASSIGN .)
    ONES            reduce using rule 57 (assign_op -> DIVASSIGN .)
    EYE             reduce using rule 57 (assign_op -> DIVASSIGN .)
    [               reduce using rule 57 (assign_op -> DIVASSIGN .)
    -               reduce using rule 57 (assign_op -> DIVASSIGN .)


state 25

    (58) assign_op -> MULASSIGN .
    ID              reduce using rule 58 (assign_op -> MULASSIGN .)
    FLOATNUM        reduce using rule 58 (assign_op -> MULASSIGN .)
    INTNUM          reduce using rule 58 (assign_op -> MULASSIGN .)
    ZEROS           reduce using rule 58 (assign_op -> MULASSIGN .)
    ONES            reduce using rule 58 (assign_op -> MULASSIGN .)
    EYE             reduce using rule 58 (assign_op -> MULASSIGN .)
    [               reduce using rule 58 (assign_op -> MULASSIGN .)
    -               reduce using rule 58 (assign_op -> MULASSIGN .)


state 26

    (59) assign_op -> SUBASSIGN .
    ID              reduce using rule 59 (assign_op -> SUBASSIGN .)
    FLOATNUM        reduce using rule 59 (assign_op -> SUBASSIGN .)
    INTNUM          reduce using rule 59 (assign_op -> SUBASSIGN .)
    ZEROS           reduce using rule 59 (assign_op -> SUBASSIGN .)
    ONES            reduce using rule 59 (assign_op -> SUBASSIGN .)
    EYE             reduce using rule 59 (assign_op -> SUBASSIGN .)
    [               reduce using rule 59 (assign_op -> SUBASSIGN .)
    -               reduce using rule 59 (assign_op -> SUBASSIGN .)


state 27

    (60) assign_op -> ADDASSIGN .
    ID              reduce using rule 60 (assign_op -> ADDASSIGN .)
    FLOATNUM        reduce using rule 60 (assign_op -> ADDASSIGN .)
    INTNUM          reduce using rule 60 (assign_op -> ADDASSIGN .)
    ZEROS           reduce using rule 60 (assign_op -> ADDASSIGN .)
    ONES            reduce using rule 60 (assign_op -> ADDASSIGN .)
    EYE             reduce using rule 60 (assign_op -> ADDASSIGN .)
    [               reduce using rule 60 (assign_op -> ADDASSIGN .)
    -               reduce using rule 60 (assign_op -> ADDASSIGN .)


state 28

    (61) assign_op -> = .
    ID              reduce using rule 61 (assign_op -> = .)
    FLOATNUM        reduce using rule 61 (assign_op -> = .)
    INTNUM          reduce using rule 61 (assign_op -> = .)
    ZEROS           reduce using rule 61 (assign_op -> = .)
    ONES            reduce using rule 61 (assign_op -> = .)
    EYE             reduce using rule 61 (assign_op -> = .)
    [               reduce using rule 61 (assign_op -> = .)
    -               reduce using rule 61 (assign_op -> = .)


state 29

    (49) instruction -> WHILE ( . condition ) instruction
    (20) condition -> . expr NE expr
    (21) condition -> . expr EQ expr
    (22) condition -> . expr GE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LE expr
    (25) condition -> . expr LT expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    condition                      shift and go to state 54
    expr                           shift and go to state 55
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 30

    (50) instruction -> IF ( . condition ) instruction ELSE instruction
    (51) instruction -> IF ( . condition ) instruction
    (20) condition -> . expr NE expr
    (21) condition -> . expr EQ expr
    (22) condition -> . expr GE expr
    (23) condition -> . expr GT expr
    (24) condition -> . expr LE expr
    (25) condition -> . expr LT expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    condition                      shift and go to state 56
    expr                           shift and go to state 55
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 31

    (52) instruction_end -> PRINT to_print .
    ;               reduce using rule 52 (instruction_end -> PRINT to_print .)


state 32

    (62) to_print -> STRING . , to_print
    (65) to_print -> STRING .
    ,               shift and go to state 57
    ;               reduce using rule 65 (to_print -> STRING .)


state 33

    (63) to_print -> expr . , to_print
    (64) to_print -> expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               shift and go to state 58
    ;               reduce using rule 64 (to_print -> expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 34

    (6) expr -> number .
    ,               reduce using rule 6 (expr -> number .)
    DOTDIV          reduce using rule 6 (expr -> number .)
    DOTMUL          reduce using rule 6 (expr -> number .)
    DOTSUB          reduce using rule 6 (expr -> number .)
    DOTADD          reduce using rule 6 (expr -> number .)
    /               reduce using rule 6 (expr -> number .)
    *               reduce using rule 6 (expr -> number .)
    -               reduce using rule 6 (expr -> number .)
    +               reduce using rule 6 (expr -> number .)
    '               reduce using rule 6 (expr -> number .)
    ;               reduce using rule 6 (expr -> number .)
    NE              reduce using rule 6 (expr -> number .)
    EQ              reduce using rule 6 (expr -> number .)
    GE              reduce using rule 6 (expr -> number .)
    GT              reduce using rule 6 (expr -> number .)
    LE              reduce using rule 6 (expr -> number .)
    LT              reduce using rule 6 (expr -> number .)
    :               reduce using rule 6 (expr -> number .)
    )               reduce using rule 6 (expr -> number .)
    {               reduce using rule 6 (expr -> number .)
    FOR             reduce using rule 6 (expr -> number .)
    WHILE           reduce using rule 6 (expr -> number .)
    IF              reduce using rule 6 (expr -> number .)
    PRINT           reduce using rule 6 (expr -> number .)
    CONTINUE        reduce using rule 6 (expr -> number .)
    BREAK           reduce using rule 6 (expr -> number .)
    RETURN          reduce using rule 6 (expr -> number .)
    ID              reduce using rule 6 (expr -> number .)


state 35

    (7) expr -> matrix_function .
    ,               reduce using rule 7 (expr -> matrix_function .)
    DOTDIV          reduce using rule 7 (expr -> matrix_function .)
    DOTMUL          reduce using rule 7 (expr -> matrix_function .)
    DOTSUB          reduce using rule 7 (expr -> matrix_function .)
    DOTADD          reduce using rule 7 (expr -> matrix_function .)
    /               reduce using rule 7 (expr -> matrix_function .)
    *               reduce using rule 7 (expr -> matrix_function .)
    -               reduce using rule 7 (expr -> matrix_function .)
    +               reduce using rule 7 (expr -> matrix_function .)
    '               reduce using rule 7 (expr -> matrix_function .)
    ;               reduce using rule 7 (expr -> matrix_function .)
    NE              reduce using rule 7 (expr -> matrix_function .)
    EQ              reduce using rule 7 (expr -> matrix_function .)
    GE              reduce using rule 7 (expr -> matrix_function .)
    GT              reduce using rule 7 (expr -> matrix_function .)
    LE              reduce using rule 7 (expr -> matrix_function .)
    LT              reduce using rule 7 (expr -> matrix_function .)
    :               reduce using rule 7 (expr -> matrix_function .)
    )               reduce using rule 7 (expr -> matrix_function .)
    {               reduce using rule 7 (expr -> matrix_function .)
    FOR             reduce using rule 7 (expr -> matrix_function .)
    WHILE           reduce using rule 7 (expr -> matrix_function .)
    IF              reduce using rule 7 (expr -> matrix_function .)
    PRINT           reduce using rule 7 (expr -> matrix_function .)
    CONTINUE        reduce using rule 7 (expr -> matrix_function .)
    BREAK           reduce using rule 7 (expr -> matrix_function .)
    RETURN          reduce using rule 7 (expr -> matrix_function .)
    ID              reduce using rule 7 (expr -> matrix_function .)


state 36

    (8) expr -> transposition .
    ,               reduce using rule 8 (expr -> transposition .)
    DOTDIV          reduce using rule 8 (expr -> transposition .)
    DOTMUL          reduce using rule 8 (expr -> transposition .)
    DOTSUB          reduce using rule 8 (expr -> transposition .)
    DOTADD          reduce using rule 8 (expr -> transposition .)
    /               reduce using rule 8 (expr -> transposition .)
    *               reduce using rule 8 (expr -> transposition .)
    -               reduce using rule 8 (expr -> transposition .)
    +               reduce using rule 8 (expr -> transposition .)
    '               reduce using rule 8 (expr -> transposition .)
    ;               reduce using rule 8 (expr -> transposition .)
    NE              reduce using rule 8 (expr -> transposition .)
    EQ              reduce using rule 8 (expr -> transposition .)
    GE              reduce using rule 8 (expr -> transposition .)
    GT              reduce using rule 8 (expr -> transposition .)
    LE              reduce using rule 8 (expr -> transposition .)
    LT              reduce using rule 8 (expr -> transposition .)
    :               reduce using rule 8 (expr -> transposition .)
    )               reduce using rule 8 (expr -> transposition .)
    {               reduce using rule 8 (expr -> transposition .)
    FOR             reduce using rule 8 (expr -> transposition .)
    WHILE           reduce using rule 8 (expr -> transposition .)
    IF              reduce using rule 8 (expr -> transposition .)
    PRINT           reduce using rule 8 (expr -> transposition .)
    CONTINUE        reduce using rule 8 (expr -> transposition .)
    BREAK           reduce using rule 8 (expr -> transposition .)
    RETURN          reduce using rule 8 (expr -> transposition .)
    ID              reduce using rule 8 (expr -> transposition .)


state 37

    (9) expr -> matrix .
    ,               reduce using rule 9 (expr -> matrix .)
    DOTDIV          reduce using rule 9 (expr -> matrix .)
    DOTMUL          reduce using rule 9 (expr -> matrix .)
    DOTSUB          reduce using rule 9 (expr -> matrix .)
    DOTADD          reduce using rule 9 (expr -> matrix .)
    /               reduce using rule 9 (expr -> matrix .)
    *               reduce using rule 9 (expr -> matrix .)
    -               reduce using rule 9 (expr -> matrix .)
    +               reduce using rule 9 (expr -> matrix .)
    '               reduce using rule 9 (expr -> matrix .)
    ;               reduce using rule 9 (expr -> matrix .)
    NE              reduce using rule 9 (expr -> matrix .)
    EQ              reduce using rule 9 (expr -> matrix .)
    GE              reduce using rule 9 (expr -> matrix .)
    GT              reduce using rule 9 (expr -> matrix .)
    LE              reduce using rule 9 (expr -> matrix .)
    LT              reduce using rule 9 (expr -> matrix .)
    :               reduce using rule 9 (expr -> matrix .)
    )               reduce using rule 9 (expr -> matrix .)
    {               reduce using rule 9 (expr -> matrix .)
    FOR             reduce using rule 9 (expr -> matrix .)
    WHILE           reduce using rule 9 (expr -> matrix .)
    IF              reduce using rule 9 (expr -> matrix .)
    PRINT           reduce using rule 9 (expr -> matrix .)
    CONTINUE        reduce using rule 9 (expr -> matrix .)
    BREAK           reduce using rule 9 (expr -> matrix .)
    RETURN          reduce using rule 9 (expr -> matrix .)
    ID              reduce using rule 9 (expr -> matrix .)


state 38

    (10) expr -> uminus .
    ,               reduce using rule 10 (expr -> uminus .)
    DOTDIV          reduce using rule 10 (expr -> uminus .)
    DOTMUL          reduce using rule 10 (expr -> uminus .)
    DOTSUB          reduce using rule 10 (expr -> uminus .)
    DOTADD          reduce using rule 10 (expr -> uminus .)
    /               reduce using rule 10 (expr -> uminus .)
    *               reduce using rule 10 (expr -> uminus .)
    -               reduce using rule 10 (expr -> uminus .)
    +               reduce using rule 10 (expr -> uminus .)
    '               reduce using rule 10 (expr -> uminus .)
    ;               reduce using rule 10 (expr -> uminus .)
    NE              reduce using rule 10 (expr -> uminus .)
    EQ              reduce using rule 10 (expr -> uminus .)
    GE              reduce using rule 10 (expr -> uminus .)
    GT              reduce using rule 10 (expr -> uminus .)
    LE              reduce using rule 10 (expr -> uminus .)
    LT              reduce using rule 10 (expr -> uminus .)
    :               reduce using rule 10 (expr -> uminus .)
    )               reduce using rule 10 (expr -> uminus .)
    {               reduce using rule 10 (expr -> uminus .)
    FOR             reduce using rule 10 (expr -> uminus .)
    WHILE           reduce using rule 10 (expr -> uminus .)
    IF              reduce using rule 10 (expr -> uminus .)
    PRINT           reduce using rule 10 (expr -> uminus .)
    CONTINUE        reduce using rule 10 (expr -> uminus .)
    BREAK           reduce using rule 10 (expr -> uminus .)
    RETURN          reduce using rule 10 (expr -> uminus .)
    ID              reduce using rule 10 (expr -> uminus .)


state 39

    (11) expr -> ID .
    ,               reduce using rule 11 (expr -> ID .)
    DOTDIV          reduce using rule 11 (expr -> ID .)
    DOTMUL          reduce using rule 11 (expr -> ID .)
    DOTSUB          reduce using rule 11 (expr -> ID .)
    DOTADD          reduce using rule 11 (expr -> ID .)
    /               reduce using rule 11 (expr -> ID .)
    *               reduce using rule 11 (expr -> ID .)
    -               reduce using rule 11 (expr -> ID .)
    +               reduce using rule 11 (expr -> ID .)
    '               reduce using rule 11 (expr -> ID .)
    ;               reduce using rule 11 (expr -> ID .)
    NE              reduce using rule 11 (expr -> ID .)
    EQ              reduce using rule 11 (expr -> ID .)
    GE              reduce using rule 11 (expr -> ID .)
    GT              reduce using rule 11 (expr -> ID .)
    LE              reduce using rule 11 (expr -> ID .)
    LT              reduce using rule 11 (expr -> ID .)
    :               reduce using rule 11 (expr -> ID .)
    )               reduce using rule 11 (expr -> ID .)
    {               reduce using rule 11 (expr -> ID .)
    FOR             reduce using rule 11 (expr -> ID .)
    WHILE           reduce using rule 11 (expr -> ID .)
    IF              reduce using rule 11 (expr -> ID .)
    PRINT           reduce using rule 11 (expr -> ID .)
    CONTINUE        reduce using rule 11 (expr -> ID .)
    BREAK           reduce using rule 11 (expr -> ID .)
    RETURN          reduce using rule 11 (expr -> ID .)
    ID              reduce using rule 11 (expr -> ID .)


state 40

    (26) uminus -> - . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 68
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 41

    (36) number -> FLOATNUM .
    ,               reduce using rule 36 (number -> FLOATNUM .)
    DOTDIV          reduce using rule 36 (number -> FLOATNUM .)
    DOTMUL          reduce using rule 36 (number -> FLOATNUM .)
    DOTSUB          reduce using rule 36 (number -> FLOATNUM .)
    DOTADD          reduce using rule 36 (number -> FLOATNUM .)
    /               reduce using rule 36 (number -> FLOATNUM .)
    *               reduce using rule 36 (number -> FLOATNUM .)
    -               reduce using rule 36 (number -> FLOATNUM .)
    +               reduce using rule 36 (number -> FLOATNUM .)
    '               reduce using rule 36 (number -> FLOATNUM .)
    ;               reduce using rule 36 (number -> FLOATNUM .)
    NE              reduce using rule 36 (number -> FLOATNUM .)
    EQ              reduce using rule 36 (number -> FLOATNUM .)
    GE              reduce using rule 36 (number -> FLOATNUM .)
    GT              reduce using rule 36 (number -> FLOATNUM .)
    LE              reduce using rule 36 (number -> FLOATNUM .)
    LT              reduce using rule 36 (number -> FLOATNUM .)
    :               reduce using rule 36 (number -> FLOATNUM .)
    )               reduce using rule 36 (number -> FLOATNUM .)
    {               reduce using rule 36 (number -> FLOATNUM .)
    FOR             reduce using rule 36 (number -> FLOATNUM .)
    WHILE           reduce using rule 36 (number -> FLOATNUM .)
    IF              reduce using rule 36 (number -> FLOATNUM .)
    PRINT           reduce using rule 36 (number -> FLOATNUM .)
    CONTINUE        reduce using rule 36 (number -> FLOATNUM .)
    BREAK           reduce using rule 36 (number -> FLOATNUM .)
    RETURN          reduce using rule 36 (number -> FLOATNUM .)
    ID              reduce using rule 36 (number -> FLOATNUM .)
    ]               reduce using rule 36 (number -> FLOATNUM .)


state 42

    (37) number -> INTNUM .
    ,               reduce using rule 37 (number -> INTNUM .)
    DOTDIV          reduce using rule 37 (number -> INTNUM .)
    DOTMUL          reduce using rule 37 (number -> INTNUM .)
    DOTSUB          reduce using rule 37 (number -> INTNUM .)
    DOTADD          reduce using rule 37 (number -> INTNUM .)
    /               reduce using rule 37 (number -> INTNUM .)
    *               reduce using rule 37 (number -> INTNUM .)
    -               reduce using rule 37 (number -> INTNUM .)
    +               reduce using rule 37 (number -> INTNUM .)
    '               reduce using rule 37 (number -> INTNUM .)
    ;               reduce using rule 37 (number -> INTNUM .)
    NE              reduce using rule 37 (number -> INTNUM .)
    EQ              reduce using rule 37 (number -> INTNUM .)
    GE              reduce using rule 37 (number -> INTNUM .)
    GT              reduce using rule 37 (number -> INTNUM .)
    LE              reduce using rule 37 (number -> INTNUM .)
    LT              reduce using rule 37 (number -> INTNUM .)
    :               reduce using rule 37 (number -> INTNUM .)
    )               reduce using rule 37 (number -> INTNUM .)
    {               reduce using rule 37 (number -> INTNUM .)
    FOR             reduce using rule 37 (number -> INTNUM .)
    WHILE           reduce using rule 37 (number -> INTNUM .)
    IF              reduce using rule 37 (number -> INTNUM .)
    PRINT           reduce using rule 37 (number -> INTNUM .)
    CONTINUE        reduce using rule 37 (number -> INTNUM .)
    BREAK           reduce using rule 37 (number -> INTNUM .)
    RETURN          reduce using rule 37 (number -> INTNUM .)
    ID              reduce using rule 37 (number -> INTNUM .)
    ]               reduce using rule 37 (number -> INTNUM .)


state 43

    (40) matrix_function -> ZEROS . ( INTNUM )
    (               shift and go to state 69


state 44

    (41) matrix_function -> ONES . ( INTNUM )
    (               shift and go to state 70


state 45

    (42) matrix_function -> EYE . ( INTNUM )
    (               shift and go to state 71


state 46

    (28) matrix -> [ . vectors ]
    (29) vectors -> . vector
    (30) vectors -> . vectors , vector
    (31) vector -> . [ elements ]
    [               shift and go to state 72

    vectors                        shift and go to state 73
    vector                         shift and go to state 74

state 47

    (55) instruction_end -> RETURN expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ;               reduce using rule 55 (instruction_end -> RETURN expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 48

    (43) assignment -> vector_init assign_op . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 75
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 49

    (44) assignment -> matrix_init assign_op . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 76
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 50

    (47) instruction -> { instructions } .
    {               reduce using rule 47 (instruction -> { instructions } .)
    FOR             reduce using rule 47 (instruction -> { instructions } .)
    WHILE           reduce using rule 47 (instruction -> { instructions } .)
    IF              reduce using rule 47 (instruction -> { instructions } .)
    PRINT           reduce using rule 47 (instruction -> { instructions } .)
    CONTINUE        reduce using rule 47 (instruction -> { instructions } .)
    BREAK           reduce using rule 47 (instruction -> { instructions } .)
    RETURN          reduce using rule 47 (instruction -> { instructions } .)
    ID              reduce using rule 47 (instruction -> { instructions } .)
    $end            reduce using rule 47 (instruction -> { instructions } .)
    }               reduce using rule 47 (instruction -> { instructions } .)
    ELSE            reduce using rule 47 (instruction -> { instructions } .)


state 51

    (48) instruction -> FOR ID = . expr : expr instruction
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 77
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 52

    (45) assignment -> ID assign_op expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ;               reduce using rule 45 (assignment -> ID assign_op expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 53

    (39) vector_init -> ID [ INTNUM . ]
    (38) matrix_init -> ID [ INTNUM . , INTNUM ]
    ]               shift and go to state 78
    ,               shift and go to state 79


state 54

    (49) instruction -> WHILE ( condition . ) instruction
    )               shift and go to state 80


state 55

    (20) condition -> expr . NE expr
    (21) condition -> expr . EQ expr
    (22) condition -> expr . GE expr
    (23) condition -> expr . GT expr
    (24) condition -> expr . LE expr
    (25) condition -> expr . LT expr
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    NE              shift and go to state 81
    EQ              shift and go to state 82
    GE              shift and go to state 83
    GT              shift and go to state 84
    LE              shift and go to state 85
    LT              shift and go to state 86
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 56

    (50) instruction -> IF ( condition . ) instruction ELSE instruction
    (51) instruction -> IF ( condition . ) instruction
    )               shift and go to state 87


state 57

    (62) to_print -> STRING , . to_print
    (62) to_print -> . STRING , to_print
    (63) to_print -> . expr , to_print
    (64) to_print -> . expr
    (65) to_print -> . STRING
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    STRING          shift and go to state 32
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    to_print                       shift and go to state 88
    expr                           shift and go to state 33
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 58

    (63) to_print -> expr , . to_print
    (62) to_print -> . STRING , to_print
    (63) to_print -> . expr , to_print
    (64) to_print -> . expr
    (65) to_print -> . STRING
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    STRING          shift and go to state 32
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 33
    to_print                       shift and go to state 89
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 59

    (12) expr -> expr DOTDIV . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 90
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 60

    (13) expr -> expr DOTMUL . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 91
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 61

    (14) expr -> expr DOTSUB . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 92
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 62

    (15) expr -> expr DOTADD . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 93
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 63

    (16) expr -> expr / . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 94
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 64

    (17) expr -> expr * . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 95
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 65

    (18) expr -> expr - . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 96
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 66

    (19) expr -> expr + . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 97
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 67

    (27) transposition -> expr ' .
    ,               reduce using rule 27 (transposition -> expr ' .)
    DOTDIV          reduce using rule 27 (transposition -> expr ' .)
    DOTMUL          reduce using rule 27 (transposition -> expr ' .)
    DOTSUB          reduce using rule 27 (transposition -> expr ' .)
    DOTADD          reduce using rule 27 (transposition -> expr ' .)
    /               reduce using rule 27 (transposition -> expr ' .)
    *               reduce using rule 27 (transposition -> expr ' .)
    -               reduce using rule 27 (transposition -> expr ' .)
    +               reduce using rule 27 (transposition -> expr ' .)
    '               reduce using rule 27 (transposition -> expr ' .)
    ;               reduce using rule 27 (transposition -> expr ' .)
    NE              reduce using rule 27 (transposition -> expr ' .)
    EQ              reduce using rule 27 (transposition -> expr ' .)
    GE              reduce using rule 27 (transposition -> expr ' .)
    GT              reduce using rule 27 (transposition -> expr ' .)
    LE              reduce using rule 27 (transposition -> expr ' .)
    LT              reduce using rule 27 (transposition -> expr ' .)
    :               reduce using rule 27 (transposition -> expr ' .)
    )               reduce using rule 27 (transposition -> expr ' .)
    {               reduce using rule 27 (transposition -> expr ' .)
    FOR             reduce using rule 27 (transposition -> expr ' .)
    WHILE           reduce using rule 27 (transposition -> expr ' .)
    IF              reduce using rule 27 (transposition -> expr ' .)
    PRINT           reduce using rule 27 (transposition -> expr ' .)
    CONTINUE        reduce using rule 27 (transposition -> expr ' .)
    BREAK           reduce using rule 27 (transposition -> expr ' .)
    RETURN          reduce using rule 27 (transposition -> expr ' .)
    ID              reduce using rule 27 (transposition -> expr ' .)


state 68

    (26) uminus -> - expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               reduce using rule 26 (uminus -> - expr .)
    DOTDIV          reduce using rule 26 (uminus -> - expr .)
    DOTMUL          reduce using rule 26 (uminus -> - expr .)
    DOTSUB          reduce using rule 26 (uminus -> - expr .)
    DOTADD          reduce using rule 26 (uminus -> - expr .)
    /               reduce using rule 26 (uminus -> - expr .)
    *               reduce using rule 26 (uminus -> - expr .)
    -               reduce using rule 26 (uminus -> - expr .)
    +               reduce using rule 26 (uminus -> - expr .)
    ;               reduce using rule 26 (uminus -> - expr .)
    NE              reduce using rule 26 (uminus -> - expr .)
    EQ              reduce using rule 26 (uminus -> - expr .)
    GE              reduce using rule 26 (uminus -> - expr .)
    GT              reduce using rule 26 (uminus -> - expr .)
    LE              reduce using rule 26 (uminus -> - expr .)
    LT              reduce using rule 26 (uminus -> - expr .)
    :               reduce using rule 26 (uminus -> - expr .)
    )               reduce using rule 26 (uminus -> - expr .)
    {               reduce using rule 26 (uminus -> - expr .)
    FOR             reduce using rule 26 (uminus -> - expr .)
    WHILE           reduce using rule 26 (uminus -> - expr .)
    IF              reduce using rule 26 (uminus -> - expr .)
    PRINT           reduce using rule 26 (uminus -> - expr .)
    CONTINUE        reduce using rule 26 (uminus -> - expr .)
    BREAK           reduce using rule 26 (uminus -> - expr .)
    RETURN          reduce using rule 26 (uminus -> - expr .)
    ID              reduce using rule 26 (uminus -> - expr .)
    '               shift and go to state 67


state 69

    (40) matrix_function -> ZEROS ( . INTNUM )
    INTNUM          shift and go to state 98


state 70

    (41) matrix_function -> ONES ( . INTNUM )
    INTNUM          shift and go to state 99


state 71

    (42) matrix_function -> EYE ( . INTNUM )
    INTNUM          shift and go to state 100


state 72

    (31) vector -> [ . elements ]
    (32) elements -> . element
    (33) elements -> . elements , element
    (34) element -> . number
    (35) element -> . ID
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    ID              shift and go to state 104
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42

    elements                       shift and go to state 101
    element                        shift and go to state 102
    number                         shift and go to state 103

state 73

    (28) matrix -> [ vectors . ]
    (30) vectors -> vectors . , vector
    ]               shift and go to state 105
    ,               shift and go to state 106


state 74

    (29) vectors -> vector .
    ]               reduce using rule 29 (vectors -> vector .)
    ,               reduce using rule 29 (vectors -> vector .)


state 75

    (43) assignment -> vector_init assign_op expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ;               reduce using rule 43 (assignment -> vector_init assign_op expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 76

    (44) assignment -> matrix_init assign_op expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ;               reduce using rule 44 (assignment -> matrix_init assign_op expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 77

    (48) instruction -> FOR ID = expr . : expr instruction
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    :               shift and go to state 107
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 78

    (39) vector_init -> ID [ INTNUM ] .
    DIVASSIGN       reduce using rule 39 (vector_init -> ID [ INTNUM ] .)
    MULASSIGN       reduce using rule 39 (vector_init -> ID [ INTNUM ] .)
    SUBASSIGN       reduce using rule 39 (vector_init -> ID [ INTNUM ] .)
    ADDASSIGN       reduce using rule 39 (vector_init -> ID [ INTNUM ] .)
    =               reduce using rule 39 (vector_init -> ID [ INTNUM ] .)


state 79

    (38) matrix_init -> ID [ INTNUM , . INTNUM ]
    INTNUM          shift and go to state 108


state 80

    (49) instruction -> WHILE ( condition ) . instruction
    (46) instruction -> . instruction_end ;
    (47) instruction -> . { instructions }
    (48) instruction -> . FOR ID = expr : expr instruction
    (49) instruction -> . WHILE ( condition ) instruction
    (50) instruction -> . IF ( condition ) instruction ELSE instruction
    (51) instruction -> . IF ( condition ) instruction
    (52) instruction_end -> . PRINT to_print
    (53) instruction_end -> . CONTINUE
    (54) instruction_end -> . BREAK
    (55) instruction_end -> . RETURN expr
    (56) instruction_end -> . assignment
    (43) assignment -> . vector_init assign_op expr
    (44) assignment -> . matrix_init assign_op expr
    (45) assignment -> . ID assign_op expr
    (39) vector_init -> . ID [ INTNUM ]
    (38) matrix_init -> . ID [ INTNUM , INTNUM ]
    {               shift and go to state 6
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    PRINT           shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    RETURN          shift and go to state 14
    ID              shift and go to state 8

    instruction                    shift and go to state 109
    instruction_end                shift and go to state 5
    assignment                     shift and go to state 15
    vector_init                    shift and go to state 16
    matrix_init                    shift and go to state 17

state 81

    (20) condition -> expr NE . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 110
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 82

    (21) condition -> expr EQ . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 111
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 83

    (22) condition -> expr GE . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 112
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 84

    (23) condition -> expr GT . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 113
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 85

    (24) condition -> expr LE . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 114
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 86

    (25) condition -> expr LT . expr
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 115
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 87

    (50) instruction -> IF ( condition ) . instruction ELSE instruction
    (51) instruction -> IF ( condition ) . instruction
    (46) instruction -> . instruction_end ;
    (47) instruction -> . { instructions }
    (48) instruction -> . FOR ID = expr : expr instruction
    (49) instruction -> . WHILE ( condition ) instruction
    (50) instruction -> . IF ( condition ) instruction ELSE instruction
    (51) instruction -> . IF ( condition ) instruction
    (52) instruction_end -> . PRINT to_print
    (53) instruction_end -> . CONTINUE
    (54) instruction_end -> . BREAK
    (55) instruction_end -> . RETURN expr
    (56) instruction_end -> . assignment
    (43) assignment -> . vector_init assign_op expr
    (44) assignment -> . matrix_init assign_op expr
    (45) assignment -> . ID assign_op expr
    (39) vector_init -> . ID [ INTNUM ]
    (38) matrix_init -> . ID [ INTNUM , INTNUM ]
    {               shift and go to state 6
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    PRINT           shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    RETURN          shift and go to state 14
    ID              shift and go to state 8

    instruction                    shift and go to state 116
    instruction_end                shift and go to state 5
    assignment                     shift and go to state 15
    vector_init                    shift and go to state 16
    matrix_init                    shift and go to state 17

state 88

    (62) to_print -> STRING , to_print .
    ;               reduce using rule 62 (to_print -> STRING , to_print .)


state 89

    (63) to_print -> expr , to_print .
    ;               reduce using rule 63 (to_print -> expr , to_print .)


state 90

    (12) expr -> expr DOTDIV expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               reduce using rule 12 (expr -> expr DOTDIV expr .)
    DOTDIV          reduce using rule 12 (expr -> expr DOTDIV expr .)
    DOTMUL          reduce using rule 12 (expr -> expr DOTDIV expr .)
    DOTSUB          reduce using rule 12 (expr -> expr DOTDIV expr .)
    DOTADD          reduce using rule 12 (expr -> expr DOTDIV expr .)
    /               reduce using rule 12 (expr -> expr DOTDIV expr .)
    *               reduce using rule 12 (expr -> expr DOTDIV expr .)
    -               reduce using rule 12 (expr -> expr DOTDIV expr .)
    +               reduce using rule 12 (expr -> expr DOTDIV expr .)
    ;               reduce using rule 12 (expr -> expr DOTDIV expr .)
    NE              reduce using rule 12 (expr -> expr DOTDIV expr .)
    EQ              reduce using rule 12 (expr -> expr DOTDIV expr .)
    GE              reduce using rule 12 (expr -> expr DOTDIV expr .)
    GT              reduce using rule 12 (expr -> expr DOTDIV expr .)
    LE              reduce using rule 12 (expr -> expr DOTDIV expr .)
    LT              reduce using rule 12 (expr -> expr DOTDIV expr .)
    :               reduce using rule 12 (expr -> expr DOTDIV expr .)
    )               reduce using rule 12 (expr -> expr DOTDIV expr .)
    {               reduce using rule 12 (expr -> expr DOTDIV expr .)
    FOR             reduce using rule 12 (expr -> expr DOTDIV expr .)
    WHILE           reduce using rule 12 (expr -> expr DOTDIV expr .)
    IF              reduce using rule 12 (expr -> expr DOTDIV expr .)
    PRINT           reduce using rule 12 (expr -> expr DOTDIV expr .)
    CONTINUE        reduce using rule 12 (expr -> expr DOTDIV expr .)
    BREAK           reduce using rule 12 (expr -> expr DOTDIV expr .)
    RETURN          reduce using rule 12 (expr -> expr DOTDIV expr .)
    ID              reduce using rule 12 (expr -> expr DOTDIV expr .)
    '               shift and go to state 67


state 91

    (13) expr -> expr DOTMUL expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               reduce using rule 13 (expr -> expr DOTMUL expr .)
    DOTDIV          reduce using rule 13 (expr -> expr DOTMUL expr .)
    DOTMUL          reduce using rule 13 (expr -> expr DOTMUL expr .)
    DOTSUB          reduce using rule 13 (expr -> expr DOTMUL expr .)
    DOTADD          reduce using rule 13 (expr -> expr DOTMUL expr .)
    /               reduce using rule 13 (expr -> expr DOTMUL expr .)
    *               reduce using rule 13 (expr -> expr DOTMUL expr .)
    -               reduce using rule 13 (expr -> expr DOTMUL expr .)
    +               reduce using rule 13 (expr -> expr DOTMUL expr .)
    ;               reduce using rule 13 (expr -> expr DOTMUL expr .)
    NE              reduce using rule 13 (expr -> expr DOTMUL expr .)
    EQ              reduce using rule 13 (expr -> expr DOTMUL expr .)
    GE              reduce using rule 13 (expr -> expr DOTMUL expr .)
    GT              reduce using rule 13 (expr -> expr DOTMUL expr .)
    LE              reduce using rule 13 (expr -> expr DOTMUL expr .)
    LT              reduce using rule 13 (expr -> expr DOTMUL expr .)
    :               reduce using rule 13 (expr -> expr DOTMUL expr .)
    )               reduce using rule 13 (expr -> expr DOTMUL expr .)
    {               reduce using rule 13 (expr -> expr DOTMUL expr .)
    FOR             reduce using rule 13 (expr -> expr DOTMUL expr .)
    WHILE           reduce using rule 13 (expr -> expr DOTMUL expr .)
    IF              reduce using rule 13 (expr -> expr DOTMUL expr .)
    PRINT           reduce using rule 13 (expr -> expr DOTMUL expr .)
    CONTINUE        reduce using rule 13 (expr -> expr DOTMUL expr .)
    BREAK           reduce using rule 13 (expr -> expr DOTMUL expr .)
    RETURN          reduce using rule 13 (expr -> expr DOTMUL expr .)
    ID              reduce using rule 13 (expr -> expr DOTMUL expr .)
    '               shift and go to state 67


state 92

    (14) expr -> expr DOTSUB expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               reduce using rule 14 (expr -> expr DOTSUB expr .)
    DOTSUB          reduce using rule 14 (expr -> expr DOTSUB expr .)
    DOTADD          reduce using rule 14 (expr -> expr DOTSUB expr .)
    -               reduce using rule 14 (expr -> expr DOTSUB expr .)
    +               reduce using rule 14 (expr -> expr DOTSUB expr .)
    ;               reduce using rule 14 (expr -> expr DOTSUB expr .)
    NE              reduce using rule 14 (expr -> expr DOTSUB expr .)
    EQ              reduce using rule 14 (expr -> expr DOTSUB expr .)
    GE              reduce using rule 14 (expr -> expr DOTSUB expr .)
    GT              reduce using rule 14 (expr -> expr DOTSUB expr .)
    LE              reduce using rule 14 (expr -> expr DOTSUB expr .)
    LT              reduce using rule 14 (expr -> expr DOTSUB expr .)
    :               reduce using rule 14 (expr -> expr DOTSUB expr .)
    )               reduce using rule 14 (expr -> expr DOTSUB expr .)
    {               reduce using rule 14 (expr -> expr DOTSUB expr .)
    FOR             reduce using rule 14 (expr -> expr DOTSUB expr .)
    WHILE           reduce using rule 14 (expr -> expr DOTSUB expr .)
    IF              reduce using rule 14 (expr -> expr DOTSUB expr .)
    PRINT           reduce using rule 14 (expr -> expr DOTSUB expr .)
    CONTINUE        reduce using rule 14 (expr -> expr DOTSUB expr .)
    BREAK           reduce using rule 14 (expr -> expr DOTSUB expr .)
    RETURN          reduce using rule 14 (expr -> expr DOTSUB expr .)
    ID              reduce using rule 14 (expr -> expr DOTSUB expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    /               shift and go to state 63
    *               shift and go to state 64
    '               shift and go to state 67


state 93

    (15) expr -> expr DOTADD expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               reduce using rule 15 (expr -> expr DOTADD expr .)
    DOTSUB          reduce using rule 15 (expr -> expr DOTADD expr .)
    DOTADD          reduce using rule 15 (expr -> expr DOTADD expr .)
    -               reduce using rule 15 (expr -> expr DOTADD expr .)
    +               reduce using rule 15 (expr -> expr DOTADD expr .)
    ;               reduce using rule 15 (expr -> expr DOTADD expr .)
    NE              reduce using rule 15 (expr -> expr DOTADD expr .)
    EQ              reduce using rule 15 (expr -> expr DOTADD expr .)
    GE              reduce using rule 15 (expr -> expr DOTADD expr .)
    GT              reduce using rule 15 (expr -> expr DOTADD expr .)
    LE              reduce using rule 15 (expr -> expr DOTADD expr .)
    LT              reduce using rule 15 (expr -> expr DOTADD expr .)
    :               reduce using rule 15 (expr -> expr DOTADD expr .)
    )               reduce using rule 15 (expr -> expr DOTADD expr .)
    {               reduce using rule 15 (expr -> expr DOTADD expr .)
    FOR             reduce using rule 15 (expr -> expr DOTADD expr .)
    WHILE           reduce using rule 15 (expr -> expr DOTADD expr .)
    IF              reduce using rule 15 (expr -> expr DOTADD expr .)
    PRINT           reduce using rule 15 (expr -> expr DOTADD expr .)
    CONTINUE        reduce using rule 15 (expr -> expr DOTADD expr .)
    BREAK           reduce using rule 15 (expr -> expr DOTADD expr .)
    RETURN          reduce using rule 15 (expr -> expr DOTADD expr .)
    ID              reduce using rule 15 (expr -> expr DOTADD expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    /               shift and go to state 63
    *               shift and go to state 64
    '               shift and go to state 67


state 94

    (16) expr -> expr / expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               reduce using rule 16 (expr -> expr / expr .)
    DOTSUB          reduce using rule 16 (expr -> expr / expr .)
    DOTADD          reduce using rule 16 (expr -> expr / expr .)
    /               reduce using rule 16 (expr -> expr / expr .)
    *               reduce using rule 16 (expr -> expr / expr .)
    -               reduce using rule 16 (expr -> expr / expr .)
    +               reduce using rule 16 (expr -> expr / expr .)
    ;               reduce using rule 16 (expr -> expr / expr .)
    NE              reduce using rule 16 (expr -> expr / expr .)
    EQ              reduce using rule 16 (expr -> expr / expr .)
    GE              reduce using rule 16 (expr -> expr / expr .)
    GT              reduce using rule 16 (expr -> expr / expr .)
    LE              reduce using rule 16 (expr -> expr / expr .)
    LT              reduce using rule 16 (expr -> expr / expr .)
    :               reduce using rule 16 (expr -> expr / expr .)
    )               reduce using rule 16 (expr -> expr / expr .)
    {               reduce using rule 16 (expr -> expr / expr .)
    FOR             reduce using rule 16 (expr -> expr / expr .)
    WHILE           reduce using rule 16 (expr -> expr / expr .)
    IF              reduce using rule 16 (expr -> expr / expr .)
    PRINT           reduce using rule 16 (expr -> expr / expr .)
    CONTINUE        reduce using rule 16 (expr -> expr / expr .)
    BREAK           reduce using rule 16 (expr -> expr / expr .)
    RETURN          reduce using rule 16 (expr -> expr / expr .)
    ID              reduce using rule 16 (expr -> expr / expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    '               shift and go to state 67


state 95

    (17) expr -> expr * expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               reduce using rule 17 (expr -> expr * expr .)
    DOTSUB          reduce using rule 17 (expr -> expr * expr .)
    DOTADD          reduce using rule 17 (expr -> expr * expr .)
    /               reduce using rule 17 (expr -> expr * expr .)
    *               reduce using rule 17 (expr -> expr * expr .)
    -               reduce using rule 17 (expr -> expr * expr .)
    +               reduce using rule 17 (expr -> expr * expr .)
    ;               reduce using rule 17 (expr -> expr * expr .)
    NE              reduce using rule 17 (expr -> expr * expr .)
    EQ              reduce using rule 17 (expr -> expr * expr .)
    GE              reduce using rule 17 (expr -> expr * expr .)
    GT              reduce using rule 17 (expr -> expr * expr .)
    LE              reduce using rule 17 (expr -> expr * expr .)
    LT              reduce using rule 17 (expr -> expr * expr .)
    :               reduce using rule 17 (expr -> expr * expr .)
    )               reduce using rule 17 (expr -> expr * expr .)
    {               reduce using rule 17 (expr -> expr * expr .)
    FOR             reduce using rule 17 (expr -> expr * expr .)
    WHILE           reduce using rule 17 (expr -> expr * expr .)
    IF              reduce using rule 17 (expr -> expr * expr .)
    PRINT           reduce using rule 17 (expr -> expr * expr .)
    CONTINUE        reduce using rule 17 (expr -> expr * expr .)
    BREAK           reduce using rule 17 (expr -> expr * expr .)
    RETURN          reduce using rule 17 (expr -> expr * expr .)
    ID              reduce using rule 17 (expr -> expr * expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    '               shift and go to state 67


state 96

    (18) expr -> expr - expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               reduce using rule 18 (expr -> expr - expr .)
    -               reduce using rule 18 (expr -> expr - expr .)
    +               reduce using rule 18 (expr -> expr - expr .)
    ;               reduce using rule 18 (expr -> expr - expr .)
    NE              reduce using rule 18 (expr -> expr - expr .)
    EQ              reduce using rule 18 (expr -> expr - expr .)
    GE              reduce using rule 18 (expr -> expr - expr .)
    GT              reduce using rule 18 (expr -> expr - expr .)
    LE              reduce using rule 18 (expr -> expr - expr .)
    LT              reduce using rule 18 (expr -> expr - expr .)
    :               reduce using rule 18 (expr -> expr - expr .)
    )               reduce using rule 18 (expr -> expr - expr .)
    {               reduce using rule 18 (expr -> expr - expr .)
    FOR             reduce using rule 18 (expr -> expr - expr .)
    WHILE           reduce using rule 18 (expr -> expr - expr .)
    IF              reduce using rule 18 (expr -> expr - expr .)
    PRINT           reduce using rule 18 (expr -> expr - expr .)
    CONTINUE        reduce using rule 18 (expr -> expr - expr .)
    BREAK           reduce using rule 18 (expr -> expr - expr .)
    RETURN          reduce using rule 18 (expr -> expr - expr .)
    ID              reduce using rule 18 (expr -> expr - expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    '               shift and go to state 67


state 97

    (19) expr -> expr + expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    ,               reduce using rule 19 (expr -> expr + expr .)
    -               reduce using rule 19 (expr -> expr + expr .)
    +               reduce using rule 19 (expr -> expr + expr .)
    ;               reduce using rule 19 (expr -> expr + expr .)
    NE              reduce using rule 19 (expr -> expr + expr .)
    EQ              reduce using rule 19 (expr -> expr + expr .)
    GE              reduce using rule 19 (expr -> expr + expr .)
    GT              reduce using rule 19 (expr -> expr + expr .)
    LE              reduce using rule 19 (expr -> expr + expr .)
    LT              reduce using rule 19 (expr -> expr + expr .)
    :               reduce using rule 19 (expr -> expr + expr .)
    )               reduce using rule 19 (expr -> expr + expr .)
    {               reduce using rule 19 (expr -> expr + expr .)
    FOR             reduce using rule 19 (expr -> expr + expr .)
    WHILE           reduce using rule 19 (expr -> expr + expr .)
    IF              reduce using rule 19 (expr -> expr + expr .)
    PRINT           reduce using rule 19 (expr -> expr + expr .)
    CONTINUE        reduce using rule 19 (expr -> expr + expr .)
    BREAK           reduce using rule 19 (expr -> expr + expr .)
    RETURN          reduce using rule 19 (expr -> expr + expr .)
    ID              reduce using rule 19 (expr -> expr + expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    '               shift and go to state 67


state 98

    (40) matrix_function -> ZEROS ( INTNUM . )
    )               shift and go to state 117


state 99

    (41) matrix_function -> ONES ( INTNUM . )
    )               shift and go to state 118


state 100

    (42) matrix_function -> EYE ( INTNUM . )
    )               shift and go to state 119


state 101

    (31) vector -> [ elements . ]
    (33) elements -> elements . , element
    ]               shift and go to state 120
    ,               shift and go to state 121


state 102

    (32) elements -> element .
    ]               reduce using rule 32 (elements -> element .)
    ,               reduce using rule 32 (elements -> element .)


state 103

    (34) element -> number .
    ]               reduce using rule 34 (element -> number .)
    ,               reduce using rule 34 (element -> number .)


state 104

    (35) element -> ID .
    ]               reduce using rule 35 (element -> ID .)
    ,               reduce using rule 35 (element -> ID .)


state 105

    (28) matrix -> [ vectors ] .
    ,               reduce using rule 28 (matrix -> [ vectors ] .)
    DOTDIV          reduce using rule 28 (matrix -> [ vectors ] .)
    DOTMUL          reduce using rule 28 (matrix -> [ vectors ] .)
    DOTSUB          reduce using rule 28 (matrix -> [ vectors ] .)
    DOTADD          reduce using rule 28 (matrix -> [ vectors ] .)
    /               reduce using rule 28 (matrix -> [ vectors ] .)
    *               reduce using rule 28 (matrix -> [ vectors ] .)
    -               reduce using rule 28 (matrix -> [ vectors ] .)
    +               reduce using rule 28 (matrix -> [ vectors ] .)
    '               reduce using rule 28 (matrix -> [ vectors ] .)
    ;               reduce using rule 28 (matrix -> [ vectors ] .)
    NE              reduce using rule 28 (matrix -> [ vectors ] .)
    EQ              reduce using rule 28 (matrix -> [ vectors ] .)
    GE              reduce using rule 28 (matrix -> [ vectors ] .)
    GT              reduce using rule 28 (matrix -> [ vectors ] .)
    LE              reduce using rule 28 (matrix -> [ vectors ] .)
    LT              reduce using rule 28 (matrix -> [ vectors ] .)
    :               reduce using rule 28 (matrix -> [ vectors ] .)
    )               reduce using rule 28 (matrix -> [ vectors ] .)
    {               reduce using rule 28 (matrix -> [ vectors ] .)
    FOR             reduce using rule 28 (matrix -> [ vectors ] .)
    WHILE           reduce using rule 28 (matrix -> [ vectors ] .)
    IF              reduce using rule 28 (matrix -> [ vectors ] .)
    PRINT           reduce using rule 28 (matrix -> [ vectors ] .)
    CONTINUE        reduce using rule 28 (matrix -> [ vectors ] .)
    BREAK           reduce using rule 28 (matrix -> [ vectors ] .)
    RETURN          reduce using rule 28 (matrix -> [ vectors ] .)
    ID              reduce using rule 28 (matrix -> [ vectors ] .)


state 106

    (30) vectors -> vectors , . vector
    (31) vector -> . [ elements ]
    [               shift and go to state 72

    vector                         shift and go to state 122

state 107

    (48) instruction -> FOR ID = expr : . expr instruction
    (6) expr -> . number
    (7) expr -> . matrix_function
    (8) expr -> . transposition
    (9) expr -> . matrix
    (10) expr -> . uminus
    (11) expr -> . ID
    (12) expr -> . expr DOTDIV expr
    (13) expr -> . expr DOTMUL expr
    (14) expr -> . expr DOTSUB expr
    (15) expr -> . expr DOTADD expr
    (16) expr -> . expr / expr
    (17) expr -> . expr * expr
    (18) expr -> . expr - expr
    (19) expr -> . expr + expr
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    (40) matrix_function -> . ZEROS ( INTNUM )
    (41) matrix_function -> . ONES ( INTNUM )
    (42) matrix_function -> . EYE ( INTNUM )
    (27) transposition -> . expr '
    (28) matrix -> . [ vectors ]
    (26) uminus -> . - expr
    ID              shift and go to state 39
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42
    ZEROS           shift and go to state 43
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    [               shift and go to state 46
    -               shift and go to state 40

    expr                           shift and go to state 123
    number                         shift and go to state 34
    matrix_function                shift and go to state 35
    transposition                  shift and go to state 36
    matrix                         shift and go to state 37
    uminus                         shift and go to state 38

state 108

    (38) matrix_init -> ID [ INTNUM , INTNUM . ]
    ]               shift and go to state 124


state 109

    (49) instruction -> WHILE ( condition ) instruction .
    {               reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    FOR             reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    WHILE           reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    IF              reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    PRINT           reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    CONTINUE        reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    BREAK           reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    RETURN          reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    ID              reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    $end            reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    }               reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)
    ELSE            reduce using rule 49 (instruction -> WHILE ( condition ) instruction .)


state 110

    (20) condition -> expr NE expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    )               reduce using rule 20 (condition -> expr NE expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 111

    (21) condition -> expr EQ expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    )               reduce using rule 21 (condition -> expr EQ expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 112

    (22) condition -> expr GE expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    )               reduce using rule 22 (condition -> expr GE expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 113

    (23) condition -> expr GT expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    )               reduce using rule 23 (condition -> expr GT expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 114

    (24) condition -> expr LE expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    )               reduce using rule 24 (condition -> expr LE expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 115

    (25) condition -> expr LT expr .
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    )               reduce using rule 25 (condition -> expr LT expr .)
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67


state 116

    (50) instruction -> IF ( condition ) instruction . ELSE instruction
    (51) instruction -> IF ( condition ) instruction .
    ELSE            shift and go to state 125
    {               reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    FOR             reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    WHILE           reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    IF              reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    PRINT           reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    CONTINUE        reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    BREAK           reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    RETURN          reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    ID              reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    $end            reduce using rule 51 (instruction -> IF ( condition ) instruction .)
    }               reduce using rule 51 (instruction -> IF ( condition ) instruction .)


state 117

    (40) matrix_function -> ZEROS ( INTNUM ) .
    ,               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    DOTDIV          reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    DOTMUL          reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    DOTSUB          reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    DOTADD          reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    /               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    *               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    -               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    +               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    '               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    ;               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    NE              reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    EQ              reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    GE              reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    GT              reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    LE              reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    LT              reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    :               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    )               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    {               reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    FOR             reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    WHILE           reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    IF              reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    PRINT           reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    CONTINUE        reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    BREAK           reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    RETURN          reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)
    ID              reduce using rule 40 (matrix_function -> ZEROS ( INTNUM ) .)


state 118

    (41) matrix_function -> ONES ( INTNUM ) .
    ,               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    DOTDIV          reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    DOTMUL          reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    DOTSUB          reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    DOTADD          reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    /               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    *               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    -               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    +               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    '               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    ;               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    NE              reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    EQ              reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    GE              reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    GT              reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    LE              reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    LT              reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    :               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    )               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    {               reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    FOR             reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    WHILE           reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    IF              reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    PRINT           reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    CONTINUE        reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    BREAK           reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    RETURN          reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)
    ID              reduce using rule 41 (matrix_function -> ONES ( INTNUM ) .)


state 119

    (42) matrix_function -> EYE ( INTNUM ) .
    ,               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    DOTDIV          reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    DOTMUL          reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    DOTSUB          reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    DOTADD          reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    /               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    *               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    -               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    +               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    '               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    ;               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    NE              reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    EQ              reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    GE              reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    GT              reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    LE              reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    LT              reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    :               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    )               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    {               reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    FOR             reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    WHILE           reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    IF              reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    PRINT           reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    CONTINUE        reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    BREAK           reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    RETURN          reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)
    ID              reduce using rule 42 (matrix_function -> EYE ( INTNUM ) .)


state 120

    (31) vector -> [ elements ] .
    ]               reduce using rule 31 (vector -> [ elements ] .)
    ,               reduce using rule 31 (vector -> [ elements ] .)


state 121

    (33) elements -> elements , . element
    (34) element -> . number
    (35) element -> . ID
    (36) number -> . FLOATNUM
    (37) number -> . INTNUM
    ID              shift and go to state 104
    FLOATNUM        shift and go to state 41
    INTNUM          shift and go to state 42

    element                        shift and go to state 126
    number                         shift and go to state 103

state 122

    (30) vectors -> vectors , vector .
    ]               reduce using rule 30 (vectors -> vectors , vector .)
    ,               reduce using rule 30 (vectors -> vectors , vector .)


state 123

    (48) instruction -> FOR ID = expr : expr . instruction
    (12) expr -> expr . DOTDIV expr
    (13) expr -> expr . DOTMUL expr
    (14) expr -> expr . DOTSUB expr
    (15) expr -> expr . DOTADD expr
    (16) expr -> expr . / expr
    (17) expr -> expr . * expr
    (18) expr -> expr . - expr
    (19) expr -> expr . + expr
    (27) transposition -> expr . '
    (46) instruction -> . instruction_end ;
    (47) instruction -> . { instructions }
    (48) instruction -> . FOR ID = expr : expr instruction
    (49) instruction -> . WHILE ( condition ) instruction
    (50) instruction -> . IF ( condition ) instruction ELSE instruction
    (51) instruction -> . IF ( condition ) instruction
    (52) instruction_end -> . PRINT to_print
    (53) instruction_end -> . CONTINUE
    (54) instruction_end -> . BREAK
    (55) instruction_end -> . RETURN expr
    (56) instruction_end -> . assignment
    (43) assignment -> . vector_init assign_op expr
    (44) assignment -> . matrix_init assign_op expr
    (45) assignment -> . ID assign_op expr
    (39) vector_init -> . ID [ INTNUM ]
    (38) matrix_init -> . ID [ INTNUM , INTNUM ]
    DOTDIV          shift and go to state 59
    DOTMUL          shift and go to state 60
    DOTSUB          shift and go to state 61
    DOTADD          shift and go to state 62
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66
    '               shift and go to state 67
    {               shift and go to state 6
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    PRINT           shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    RETURN          shift and go to state 14
    ID              shift and go to state 8

    instruction                    shift and go to state 127
    instruction_end                shift and go to state 5
    assignment                     shift and go to state 15
    vector_init                    shift and go to state 16
    matrix_init                    shift and go to state 17

state 124

    (38) matrix_init -> ID [ INTNUM , INTNUM ] .
    DIVASSIGN       reduce using rule 38 (matrix_init -> ID [ INTNUM , INTNUM ] .)
    MULASSIGN       reduce using rule 38 (matrix_init -> ID [ INTNUM , INTNUM ] .)
    SUBASSIGN       reduce using rule 38 (matrix_init -> ID [ INTNUM , INTNUM ] .)
    ADDASSIGN       reduce using rule 38 (matrix_init -> ID [ INTNUM , INTNUM ] .)
    =               reduce using rule 38 (matrix_init -> ID [ INTNUM , INTNUM ] .)


state 125

    (50) instruction -> IF ( condition ) instruction ELSE . instruction
    (46) instruction -> . instruction_end ;
    (47) instruction -> . { instructions }
    (48) instruction -> . FOR ID = expr : expr instruction
    (49) instruction -> . WHILE ( condition ) instruction
    (50) instruction -> . IF ( condition ) instruction ELSE instruction
    (51) instruction -> . IF ( condition ) instruction
    (52) instruction_end -> . PRINT to_print
    (53) instruction_end -> . CONTINUE
    (54) instruction_end -> . BREAK
    (55) instruction_end -> . RETURN expr
    (56) instruction_end -> . assignment
    (43) assignment -> . vector_init assign_op expr
    (44) assignment -> . matrix_init assign_op expr
    (45) assignment -> . ID assign_op expr
    (39) vector_init -> . ID [ INTNUM ]
    (38) matrix_init -> . ID [ INTNUM , INTNUM ]
    {               shift and go to state 6
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    PRINT           shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    RETURN          shift and go to state 14
    ID              shift and go to state 8

    instruction                    shift and go to state 128
    instruction_end                shift and go to state 5
    assignment                     shift and go to state 15
    vector_init                    shift and go to state 16
    matrix_init                    shift and go to state 17

state 126

    (33) elements -> elements , element .
    ]               reduce using rule 33 (elements -> elements , element .)
    ,               reduce using rule 33 (elements -> elements , element .)


state 127

    (48) instruction -> FOR ID = expr : expr instruction .
    {               reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    FOR             reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    WHILE           reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    IF              reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    PRINT           reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    CONTINUE        reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    BREAK           reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    RETURN          reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    ID              reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    $end            reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    }               reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)
    ELSE            reduce using rule 48 (instruction -> FOR ID = expr : expr instruction .)


state 128

    (50) instruction -> IF ( condition ) instruction ELSE instruction .
    {               reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    FOR             reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    WHILE           reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    IF              reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    PRINT           reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    BREAK           reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    RETURN          reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    ID              reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    $end            reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    }               reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
    ELSE            reduce using rule 50 (instruction -> IF ( condition ) instruction ELSE instruction .)
